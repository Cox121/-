# 内存是如何存储的？
## 原始类型  
原始类型包括`null`、`undefined`、`boolean`、`number`、`string`、`symbol`、`bigInt`，保存在内存栈空间中。
## 引用类型
引用类型只有`object`，栈空间中仅保存值的引用，值保存在堆空间。赋值操作只会复制值的引用。
# 内存是如何回收的？
## 栈空间内存回收机制
栈空间中的内存在执行上下文切换后，指示当前执行上下文的指针下移即完成了回收。后续执行代码产生的执行上下文会直接覆盖指针以上的内存，从而达到内存空间重复利用的目的。
## 堆空间内存回收机制
> 代际假说：  
> * 新生的对象在内存中存在的时间很短。
> * 不死的对象可以活得很久。

`chrome`基于代际假说理论，将不同的数据分为新生区和老生区存储。  
### 新生区
新生区负责存储存存活时间较短的和内存占用较小的数据。  
新生区使用副垃圾回收器进行垃圾回收。  
新生区采用分块的策略，将内存分为对象区域和空闲区域。当对象区域快要写满时进行垃圾回收。  
垃圾回收过程：  
1. 对象区域中仍被引用的对象标记为活动对象。  
2. 将其复制到空闲区域并有序排列。  
将活动对象有序排列的操作避免了内存碎片的产生。  
3. 将对象区域中的内容清空。  
4. 将两个区域对调，使原先的对象区域成为空闲区域，原先的空闲区域成为对象区域。  
在新生区中经历两次垃圾回收任然存活的对象，转入老生区。  

### 老生区
老生区负责存储存活时间长或者内存占用较大的数据。  
老生区使用主垃圾回收器进行垃圾回收。  
垃圾回收过程：  
1. 从根对象开始遍历，标记出活动对象和不活动对象。
2. 将活动对象全部移动到一端。
这一步完成了内存整理功能，避免产生内存碎片。
3. 清空活动对象端边界外所有内存。

### 增量标记机制

垃圾回收过程中会占用主线程，一旦开始回收，`js`代码的执行就要停止，这称之为**全停顿**。  
为了避免全停顿时间太长造成不好的用户体验，`chorme`采用增量标记策略，将最耗时的标记过程拆分成一个个小任务，穿插在代码运行中执行。