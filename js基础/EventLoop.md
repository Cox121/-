# `EventLoop`
为了解决单线程无法处理不同来源同时并发的任务的问题，浏览器内部维护了一个消息队列，用于收集并发的任务。并开启一个循环线程，循环将消息队列头部的任务取出，放在主线程上执行。这个机制称之为`EventLoop`。

## 宏任务
事件循环过程中，消息队列内的任务都为宏任务。

### 定时器
为了实现定时器的延迟执行效果，浏览器内部还维护了一个延迟执行的`HashMap`结构，将需要延迟执行的任务信息保存在延迟执行`Map`中。在一次循环中，宏任务执行结束后，会检查当前是否有已经到期的任务，存在到期任务则将其全部执行。

### `xhrHttpRequest`
渲染进程通知网络进程发起网络请求，等请求拿到结果后，网络进程通知渲染进程，渲染进程回调任务添加进消息队列。

## 微任务
在全局执行上下文创建的同时，会创建一个微任务队列，在一次宏任务即将执行结束前，会检查当前微任务队列中是否存在任务，如果存在会将其全部取出执行，直到微任务队列全部清空，才开始下一次循环。

### `promise`
`promise`核心机制：
1. 回调函数延迟绑定
回调函数被包装成微任务，故而能够保证执行的时候回调函数存在。
2. 回调函数返回值穿透
then方法返回一个`promise`


### `async/await`

#### `generator`
`generator`实现原理是协程，`generator`函数执行时候保存父协程的调用栈然后创建一个子协程，并将主线程的控制权交给子协程，子协程开始执行函数。遇到`yield`的时候将主线程的控制权交还给父协程，并保存子协程的调用栈，恢复父协程的调用栈继续执行。在父协程中调用子协程的`next`函数时，保存父协程的调用栈，恢复子协程的调用栈，并继续执行子协程上的函数。

#### `async`
`async`将修饰的函数的返回值隐性地转化为`promise`，调用`async`函数的时候，会创建一个子协程，并在子协程上执行。

#### `await`
代码执行遇到`await`函数的时候，将创建一个子协程，并在子协程上执行其后续跟随表达式，当表达式返回后将结果返回给父协程并继续执行。