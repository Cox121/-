# 1. 数据响应系统初始化
在数据初始化阶段，会初始化一个`Observer`，将需要转化为响应式的数据作为参数传入，在`Observer`初始化过程中，会根据值的类型不同，做出不同处理：
## 1.1 普通类型的响应式转化
通过`definedProperty`对该项设置`getter`、`setter`
## 1.2 `Object`类型的响应式转化
通过`definedProperty`对该项设置`getter`、`setter`，遍历每一个`key`，通过`definedProperty`对每一项设置`getter`、`setter`，进行深度观测。  
## 1.3 `Array`类型的响应式转化
通过`definedProperty`对该项设置`getter`、`setter`
`Vue`会将`Array.prototype`复制一份，并将其原有的方法改写为如下逻辑：  
1. 执行原逻辑。  
2. 如果是插入的方法，将插入的内容进行响应式处理。  
3. 通过`__ob__`触发更新。  

然后根据是否支持`__proto__`属性对数组原方法进行覆盖。  
最后遍历每一项，通过`definedProperty`对每一项设置`getter`、`setter`。  

`__ob__`属性在进行响应式转化之前生成，指向该对象对应的`Observer`。  
响应式转换过程中也会初始化一个依赖收集器`Dep`的实例`dep`，在`getter`和`setter`中被闭包引用。  
# 2. 依赖收集
## 2.1 依赖收集的触发
在`Vue`中依赖收集触发分为以下几种情况：
1. 开发者定义的`watch`的依赖收集。
在`Vue`初始化处理开发者定义的`watch`的过程中，会针对`watch`中的每一项初始化一个`Watcher`实例，并将每一项的`key`作为参数传进`Watcher`。  
在`Watcher`初始化的过程中，会判断传入的是一个`key`还是一个函数，如果是`key`，会对`key`进行解析并生成一个触发取值的函数。
在后续初始化过程中，会调用取值函数，从而触发了`getter`，开始了依赖收集过程。  
如用取值函数的过程中，如果发现`Watcher`的`deep`属性为`true`则会值进行递归，触发深层依赖收集。  
2. 模板插值的依赖收集。
`Vue`在初始化过程中，会创建一个`Watcher`。  
其对应普通`Watcher`传入`key`参数的位置传入的是触发渲染的函数，所以替代普通函数触发取值函数的过程变成了触发首次渲染。  
模板插值会在渲染函数中进行取值操作，从而触发了`getter`，开始了依赖收集过程。  

在依赖收集完成之后，会先将`Watcher`数组的最后一个删除， 将`Dep.terget`恢复为删除后数组的最后一项。  

## 2.2 依赖收集过程
在依赖收集触发之前，会先将当前`Watcher`推入一个保存`Watcher`的数组，并将`Dep`的`target`属性设置为当前`Watcher`，文中称之为收集目标。  
依赖收集被触发后，会通过将当前`Watcher`被保存在`dep`某属性中的方式建立联系，完成依赖收集。
并且如果子节点也是响应式对象，子节点的`Observer`也会收集当前依赖，保证子节点的响应式数据发送变化时，当前数据的`Watcher`也能被触发。  
在依赖收集触发之前，会先将`Watcher`数组的最后一个删除， 将`Dep.terget`恢复为删除后数组的最后一项，保证在依赖收集过程中触发另一数据的依赖收集后能恢复原来的收集目标。

## 2.3 防止依赖重复收集的机制
每个`Watcher`内部维护了两个`Set`和两个数组，数组保存上次和这次依赖当前`Watcher`的`Dep`，`Set`保存上次和这次依赖当前`Watcher`的`Dep`的`id`。
在每次依赖被收集之前，会先检测这个`Dep`的`id`是否存在上次依赖的`Set`内，如果不存在则说明未跟上次重复，正常进行依赖收集，并将`Dep`保存在新`Dep`数组中，如果存在则无需进行任何操作。
在每次依赖收集之后，会检测上一次已经依赖的`Dep`是否在这次是否仍然依赖，如果不依赖了，会将其解除依赖。
最后将两个`Set`和两个数组互换，将这次的`Dep`作为下一次依赖收集的上一次依赖`Dep`信息，并清空新依赖的`Set`和数组。
总的来说，`Vue`通过保证此次收集的依赖未在上次收集，上次收集的依赖在此次收集中不再依赖来防止依赖收集。

# 3. 派发更新
1. 调用`getter`获取当前值
2. 判断当前值和新值是否一样，一样的话停止派发
3. 判断数据转化为响应式之前是否存在`setter`，如果存在`setter`则调用`setter`，如果不存在，则将老值更改为新值
4. 将新值转换成响应式数据
5. 通知闭包引用的`dep`开始更新派发
6. 将收集到的`Watcher`由`id`从小到大排列， 依赖从前往后触发，确保同步更新的顺序不出错
    1. 父节点先于子节点创建，父节点的`Watcher`理应先触发。
    2. 父节点的`Watcher`中可能存在销毁子节点的逻辑，因此父节点的`Watcher`应该先更新
    3. 开发者定义的`Watcher`要比渲染`Watcher`先触发，开发者定义的`Watcher`中也会触发更新的派发，先于渲染`Watcher`触发可以合并几次渲染更新的派发。
7. 排列触发队列
    1. 判断`Watcher`是否已经存在触发队列中，已经存在则不进行处理
    2. 根据当前是否正在更新，将`Watcher`插入触发队列中合理的位置
        1. 不在更新：插入末尾
        2. 在更新：插入未触发且`id`比当前`Watcher`大的`Watcher`之前
9. 按需求同步或者异步执行触发队列
10. 重新收集依赖
11. 触发回调


